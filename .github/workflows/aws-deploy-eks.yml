name: Deploy to AWS EKS

on:
  push:
    branches:
      - main      # Production
      - develop   # Staging
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      deploy_ims:
        description: 'Deploy IMS'
        required: false
        default: true
        type: boolean
      deploy_api:
        description: 'Deploy API'
        required: false
        default: true
        type: boolean

env:
  AWS_REGION: af-south-1
  ECR_REGISTRY_PREFIX: partpal

jobs:
  determine-environment:
    name: Determine Environment
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      cluster_name: ${{ steps.set-env.outputs.cluster_name }}
      namespace: ${{ steps.set-env.outputs.namespace }}
    steps:
      - name: Set Environment
        id: set-env
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            ENV="${{ github.event.inputs.environment }}"
          elif [ "${{ github.ref }}" == "refs/heads/main" ]; then
            ENV="production"
          else
            ENV="staging"
          fi

          echo "environment=${ENV}" >> $GITHUB_OUTPUT
          echo "cluster_name=partpal-${ENV}" >> $GITHUB_OUTPUT
          echo "namespace=partpal" >> $GITHUB_OUTPUT

  detect-changes:
    name: Detect Changes
    runs-on: ubuntu-latest
    outputs:
      apps-ims: ${{ steps.changes.outputs.apps-ims }}
      services-api: ${{ steps.changes.outputs.services-api }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check for changes
        uses: dorny/paths-filter@v2
        id: changes
        with:
          filters: |
            apps-ims:
              - 'apps/ims/**'
              - 'packages/**'
            services-api:
              - 'services/api/**'
              - 'packages/**'

  deploy-api:
    name: Deploy API
    runs-on: ubuntu-latest
    needs: [determine-environment, detect-changes]
    if: |
      (needs.detect-changes.outputs.services-api == 'true' || github.event.inputs.deploy_api == 'true') &&
      (github.event_name != 'workflow_dispatch' || github.event.inputs.deploy_api == 'true')

    environment:
      name: ${{ needs.determine-environment.outputs.environment }}
      url: https://api.partpal.co.za

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig \
            --region ${{ env.AWS_REGION }} \
            --name ${{ needs.determine-environment.outputs.cluster_name }}

      - name: Deploy API to EKS
        run: |
          ENVIRONMENT=${{ needs.determine-environment.outputs.environment }}
          NAMESPACE=${{ needs.determine-environment.outputs.namespace }}
          ECR_REGISTRY=${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG="${GITHUB_SHA::8}"

          # Create namespace if it doesn't exist
          kubectl create namespace ${NAMESPACE} --dry-run=client -o yaml | kubectl apply -f -

          # Deploy API
          cat <<EOF | kubectl apply -f -
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: partpal-api
            namespace: ${NAMESPACE}
            labels:
              app: partpal-api
              environment: ${ENVIRONMENT}
          spec:
            replicas: 2
            selector:
              matchLabels:
                app: partpal-api
            strategy:
              type: RollingUpdate
              rollingUpdate:
                maxSurge: 1
                maxUnavailable: 0
            template:
              metadata:
                labels:
                  app: partpal-api
                  environment: ${ENVIRONMENT}
                  version: ${IMAGE_TAG}
              spec:
                containers:
                - name: api
                  image: ${ECR_REGISTRY}/${ECR_REGISTRY_PREFIX}-${ENVIRONMENT}-api:${IMAGE_TAG}
                  ports:
                  - containerPort: 3333
                    name: http
                  env:
                  - name: NODE_ENV
                    value: "${ENVIRONMENT}"
                  - name: DATABASE_URL
                    valueFrom:
                      secretKeyRef:
                        name: partpal-secrets
                        key: database-url
                  - name: REDIS_URL
                    valueFrom:
                      secretKeyRef:
                        name: partpal-secrets
                        key: redis-url
                  - name: JWT_SECRET
                    valueFrom:
                      secretKeyRef:
                        name: partpal-secrets
                        key: jwt-secret
                  - name: CLOUDINARY_CLOUD_NAME
                    valueFrom:
                      secretKeyRef:
                        name: partpal-secrets
                        key: cloudinary-cloud-name
                  - name: CLOUDINARY_API_KEY
                    valueFrom:
                      secretKeyRef:
                        name: partpal-secrets
                        key: cloudinary-api-key
                  - name: CLOUDINARY_API_SECRET
                    valueFrom:
                      secretKeyRef:
                        name: partpal-secrets
                        key: cloudinary-api-secret
                  resources:
                    requests:
                      memory: "256Mi"
                      cpu: "250m"
                    limits:
                      memory: "512Mi"
                      cpu: "500m"
                  livenessProbe:
                    httpGet:
                      path: /api/health
                      port: 3333
                    initialDelaySeconds: 30
                    periodSeconds: 10
                    timeoutSeconds: 5
                    failureThreshold: 3
                  readinessProbe:
                    httpGet:
                      path: /api/health
                      port: 3333
                    initialDelaySeconds: 5
                    periodSeconds: 5
                    timeoutSeconds: 3
                    failureThreshold: 3
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: partpal-api-service
            namespace: ${NAMESPACE}
          spec:
            selector:
              app: partpal-api
            ports:
            - protocol: TCP
              port: 80
              targetPort: 3333
            type: ClusterIP
          EOF

      - name: Wait for API deployment
        run: |
          kubectl rollout status deployment/partpal-api \
            -n ${{ needs.determine-environment.outputs.namespace }} \
            --timeout=5m

      - name: Run health check
        run: |
          kubectl wait --for=condition=ready pod \
            -l app=partpal-api \
            -n ${{ needs.determine-environment.outputs.namespace }} \
            --timeout=3m

  deploy-ims:
    name: Deploy IMS
    runs-on: ubuntu-latest
    needs: [determine-environment, detect-changes, deploy-api]
    if: |
      always() &&
      (needs.deploy-api.result == 'success' || needs.deploy-api.result == 'skipped') &&
      (needs.detect-changes.outputs.apps-ims == 'true' || github.event.inputs.deploy_ims == 'true') &&
      (github.event_name != 'workflow_dispatch' || github.event.inputs.deploy_ims == 'true')

    environment:
      name: ${{ needs.determine-environment.outputs.environment }}
      url: https://ims.partpal.co.za

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Update kubeconfig
        run: |
          aws eks update-kubeconfig \
            --region ${{ env.AWS_REGION }} \
            --name ${{ needs.determine-environment.outputs.cluster_name }}

      - name: Deploy IMS to EKS
        run: |
          ENVIRONMENT=${{ needs.determine-environment.outputs.environment }}
          NAMESPACE=${{ needs.determine-environment.outputs.namespace }}
          ECR_REGISTRY=${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG="${GITHUB_SHA::8}"

          kubectl apply -f - <<EOF
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: partpal-ims
            namespace: ${NAMESPACE}
          spec:
            replicas: 2
            selector:
              matchLabels:
                app: partpal-ims
            template:
              metadata:
                labels:
                  app: partpal-ims
              spec:
                containers:
                - name: ims
                  image: ${ECR_REGISTRY}/${ECR_REGISTRY_PREFIX}-${ENVIRONMENT}-ims:${IMAGE_TAG}
                  ports:
                  - containerPort: 3001
                  env:
                  - name: NODE_ENV
                    value: "${ENVIRONMENT}"
                  - name: NEXT_PUBLIC_API_URL
                    value: "https://api.partpal.co.za"
                  resources:
                    requests:
                      memory: "256Mi"
                      cpu: "250m"
                    limits:
                      memory: "512Mi"
                      cpu: "500m"
          ---
          apiVersion: v1
          kind: Service
          metadata:
            name: partpal-ims-service
            namespace: ${NAMESPACE}
          spec:
            selector:
              app: partpal-ims
            ports:
            - protocol: TCP
              port: 80
              targetPort: 3001
            type: ClusterIP
          EOF

          kubectl rollout status deployment/partpal-ims -n ${NAMESPACE} --timeout=5m

  post-deployment:
    name: Post-Deployment Tests
    runs-on: ubuntu-latest
    needs: [determine-environment, deploy-api, deploy-ims]
    if: always()
    steps:
      - name: Deployment Summary
        run: |
          echo "## PartPal IMS Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** ${{ needs.determine-environment.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "**Cluster:** ${{ needs.determine-environment.outputs.cluster_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Namespace:** ${{ needs.determine-environment.outputs.namespace }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Service | Status |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|--------|" >> $GITHUB_STEP_SUMMARY
          echo "| API Backend | ${{ needs.deploy-api.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "| IMS Frontend | ${{ needs.deploy-ims.result }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**IMS URL:** https://ims.partpal.co.za" >> $GITHUB_STEP_SUMMARY
